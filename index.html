<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="">
  <meta property="og:type" content="">
  <meta property="og:url" content="">
  <meta property="og:image" content="">

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">

  <meta name="theme-color" content="#fafafa">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Babylon Template</title>
  <style>
    html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
    #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
    }
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
</head>

<body>
  <canvas id="renderCanvas"></canvas>

  <script src="js/vendor/modernizr-3.11.2.min.js"></script>
  <script src="js/plugins.js"></script>
  <script src="js/main.js"></script>
    <script type="module">
        import setUpButtons from './js/buttonConfig.js';
        import setUpHUD from './js/HUDConfig.js';

        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true ,{ stencil: true }); // Generate the BABYLON 3D engine
        let advancedTexture;
        let startGameButton;
        let player1 = {};
        let player2 = {};

        const buttonList = {
            startGameButton,
            player1, 
            player2
        };

        let player1Score = {},
            player2Score= {},
            scoreLabel1 = {},
            scoreLabel2 = {},
            title = {},
            subtitle = {},
            question = {}; 


        const HUD = {
            player1Score,
            player2Score,
            scoreLabel1,
            scoreLabel2,
            title,
            subtitle,
            question
        }

        let cube;
      

        const createScene = async function () {
            // Creates a basic Babylon Scene object
            const scene = new BABYLON.Scene(engine);
            // Creates and positions a free camera
            const camera = new BABYLON.UniversalCamera("camera1", 
                // new BABYLON.Vector3(0, 2, 0), scene);
                new BABYLON.Vector3(0, 15, 0), scene);
            // Targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());
            // This attaches the camera to the canvas
            // camera.attachControl(canvas, true);
            // Creates a light, aiming 0,1,0 - to the sky
            const light = new BABYLON.HemisphericLight("light", 
                new BABYLON.Vector3(0, 1, 0), scene);
            // Dim the light a small amount - 0 to 1
            light.intensity = 0.7;
            // Built-in 'sphere' shape.
            const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", 
                {diameter: 2, segments: 32}, scene);
            // Move the sphere upward 1/2 its height
            sphere.position.y = 1;


            var faceColors = [];
                faceColors[0] = BABYLON.Color3.Blue();
                faceColors[1] = BABYLON.Color3.Red();
                faceColors[2] = BABYLON.Color3.Green();
                faceColors[3] = BABYLON.Color3.White();
                faceColors[4] = BABYLON.Color3.Yellow();
                faceColors[5] = BABYLON.Color3.Black();

            const options = {
                size: 1,
                faceColors
            }

            cube = BABYLON.MeshBuilder.CreateBox("box", options, scene);
            cube.position.x = 4.3;
            cube.position.y = 2.5;
            cube.position.z = 2;
            cube.id="answer1";

            cube.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            // const myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            // myMaterial.diffuseColor = new BABYLON.Color3.FromHexString("#1B97C2");
            // cube.material = myMaterial;


            // Built-in 'ground' shape.
            const ground = BABYLON.MeshBuilder.CreateGround("ground", 
                {width: 16, height: 12}, scene);
            //GUI
            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI", true, scene);
            let loadedGUI = await advancedTexture.parseFromURLAsync("./json/guiTexture.json");

            setUpButtons(advancedTexture, buttonList);
            setUpHUD(advancedTexture, HUD);

            HUD.question.isVisible = false;
            // debugger;
            buttonList.startGameButton.onPointerUpObservable.add(function() {
                    hideTitleScreen();
            });

            return scene;
        };
        const PromiseScene = createScene(); //Call the createScene function that returns a promise
         PromiseScene.then(scene => {
            scene.debugLayer.show();//show debugger
            // Register a render loop to repeatedly render the scene
            engine.runRenderLoop(function () {
                scene.render();
                // console.log(scene.pointerX + '||' + scene.pointerY);
            });
            const hl = new BABYLON.HighlightLayer("hl1", scene);
            scene.onKeyboardObservable.add((kbInfo) => {
                if(kbInfo.type == BABYLON.KeyboardEventTypes.KEYDOWN){
                    switch (kbInfo.event.key) {
                            case 'A':
                            case 'a':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                            // Add the highlight layer.
                           
                            hl.addMesh(cube, BABYLON.Color3.Green());
                            HUD.player1Score.text = Number(HUD.player1Score.text) + 1;
                                break;
                            case 'S':
                            case 's':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                                break;
                            case 'D':
                            case 'd':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                                break;
                            case 'ArrowLeft':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                                break;
                            case 'ArrowUp':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                                break;
                            case 'ArrowRight':
                            console.log("KEY DOWN: ", kbInfo.event.key);
                                break;
    
                        }
                }
                else{
                    hl.removeMesh(cube);
                }
            });

            buttonList.player1.answer1.onPointerUpObservable.add(function(e) {
                    console.log(e);
                   const pick = scene.pick(e.x, e.y);
                   console.log(advancedTexture.pick(e.x, e.y));
                 
                //    console.log(pick);
                //         setTimeout(() => {
                //             scene.simulatePointerDown(pick)
                //             console.log('timeout');
                //             scene.simulatePointerUp(pick)
                // }, 3000)

             });
           


        })

    
       
       
        const hideTitleScreen = () => {
                HUD.title.isVisible = false;
                HUD.subtitle.isVisible = false;
               
                buttonList.startGameButton.isVisible = false;

                for (const button in buttonList.player1) {
                    buttonList.player1[button].isVisible = true;
                }
                for (const button in buttonList.player2) {
                    buttonList.player2[button].isVisible = true;
                }
                HUD.question.isVisible = true;
        }
      
        
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>
</body>

</html>
